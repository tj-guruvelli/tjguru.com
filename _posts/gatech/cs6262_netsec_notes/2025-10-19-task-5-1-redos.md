---
title: Task 5.1 - Regular Expression Denial of Service (ReDoS)
date: 2025-10-19 00:00:00 +0000
categories: [Gatech, Courses]
hidden: true
published: false
tags: [redos, denial-of-service, regex, catastrophic-backtracking]
toc: true
---

## Background

Regular Expression Denial of Service (ReDoS) is an application-layer denial of service attack that exploits inefficient regular expression patterns. Unlike traditional DoS attacks that flood the network with traffic, ReDoS attacks use carefully crafted input to cause the regex engine to enter a state of "catastrophic backtracking," consuming excessive CPU time and potentially freezing the application.

### Why ReDoS Matters

In single-threaded environments like JavaScript (Node.js) or Python's default execution model, a long-running regex operation can block the entire event loop, making the application unresponsive to all users. This is particularly dangerous for web servers that validate user input with regular expressions.

## Understanding Catastrophic Backtracking

### How Regex Engines Work

Most regex engines use a backtracking algorithm to match patterns. When a pattern fails to match, the engine "backtracks" to try alternative paths through the pattern.

**Example:** Matching `a+b` against `aaac`

```
Pattern: a+b
Input:   aaac

Step 1: a+ matches "aaa"
Step 2: b tries to match "c" → fails
Step 3: Backtrack - a+ matches "aa", b tries to match "a" → fails
Step 4: Backtrack - a+ matches "a", b tries to match "a" → fails
Step 5: Backtrack - a+ matches "", b tries to match "a" → fails
Result: No match (after 5 steps)
```

This is normal backtracking and completes quickly.

### Catastrophic Backtracking

Certain patterns cause **exponential** backtracking when they fail to match:

**Vulnerable pattern:** `(a+)+b`

This pattern has **nested quantifiers** - a `+` inside another `+`. When matching fails, the engine tries every possible way to distribute the characters between the inner and outer quantifiers.

**Example:** Matching `(a+)+b` against `aaac`

```
Pattern: (a+)+b
Input:   aaac

The engine tries:
1. (a+)+ matches "aaa" as one group, b tries "c" → fail
2. (a+)+ matches "aa" + "a" as two groups, b tries "c" → fail
3. (a+)+ matches "a" + "aa" as two groups, b tries "c" → fail
4. (a+)+ matches "a" + "a" + "a" as three groups, b tries "c" → fail
... and many more combinations

For n characters, there are 2^n possible ways to group them!
```

### Time Complexity

| Input Length  | Possible Groupings   | Time        |
| ------------- | -------------------- | ----------- |
| 3 characters  | 2^3 = 8              | ~1ms        |
| 10 characters | 2^10 = 1,024         | ~10ms       |
| 20 characters | 2^20 = 1,048,576     | ~1 second   |
| 30 characters | 2^30 = 1,073,741,824 | ~18 minutes |

The time grows **exponentially** with input length.

## The Attack

### Vulnerable Pattern

The application used a regex pattern to validate usernames:

```javascript
// Vulnerable regex (simplified example)
const usernamePattern = /^(a+)+$/;

function validateUsername(username) {
  return usernamePattern.test(username);
}
```

This pattern has nested quantifiers: `(a+)+`

### Crafting the Payload

The attack requires:

1. **Username:** A regex pattern that causes catastrophic backtracking
2. **Password:** Input that triggers the backtracking

**Username:** `((a+)+)+b`

This pattern has **triple-nested quantifiers**, making the backtracking even worse.

**Password:** `aaaaaaaaaaaaaaaaaaaac` (22 'a's followed by 'c')

The 'c' at the end ensures the pattern fails to match (since the pattern expects 'b'), forcing the engine to try all possible combinations.

### Implementation

```javascript
// Login attempt
username: ((a+)+)+b
password: aaaaaaaaaaaaaaaaaaaac
```

When the server validates this input:

```javascript
const pattern = new RegExp(username); // Creates pattern: /((a+)+)+b/
const result = pattern.test(password); // Tests: "aaaaaaaaaaaaaaaaaaaac"
```

The regex engine enters catastrophic backtracking, consuming CPU for 5+ seconds and blocking the event loop.

### Result

**Success hash:** `24eca8e303b440182e78bff6ac1474a6e5d445466f478b209ef530096eafaf4ef6d34b89f0ae72cc842cc6a347dc54566fcb391262c6886bfd08109e345ad5ec`

The server hung for over 5 seconds, proving the ReDoS attack was successful.

## Why It Works

### The Vulnerability Chain

1. **Application accepts user input as regex** - The username field is used to construct a regex pattern
2. **No timeout on regex execution** - The regex engine runs indefinitely
3. **Single-threaded environment** - JavaScript's event loop is blocked
4. **Nested quantifiers** - The pattern `((a+)+)+b` causes exponential backtracking
5. **Input designed to fail** - The password ends with 'c' instead of 'b', forcing maximum backtracking

### Execution Timeline

```
t=0ms:     Server receives login request
t=0ms:     Creates regex pattern: /((a+)+)+b/
t=0ms:     Starts matching against: "aaaaaaaaaaaaaaaaaaaac"
t=0ms:     Regex engine begins backtracking
t=1000ms:  Still backtracking...
t=2000ms:  Still backtracking...
t=3000ms:  Still backtracking...
t=4000ms:  Still backtracking...
t=5000ms:  Still backtracking...
t=5000ms+: Finally completes (no match)
t=5000ms+: Server responds with hash (proving >5s delay)
```

During this time, the server cannot process any other requests.

## Real-World Examples

### Example 1: Email Validation

```javascript
// Vulnerable email regex
const emailPattern = /^([a-zA-Z0-9]+)*@([a-zA-Z0-9]+)*\.com$/;

// Attack input
const email = "aaaaaaaaaaaaaaaaaaaaaaaaa!";
```

The nested `+` quantifiers cause exponential backtracking when the input doesn't match.

### Example 2: URL Validation

```javascript
// Vulnerable URL regex
const urlPattern =
  /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;

// Attack input
const url = "http://aaaaaaaaaaaaaaaaaaaaaaaa!";
```

The `([\/\w \.-]*)*` part has nested quantifiers.

### Example 3: HTML Tag Matching

```javascript
// Vulnerable HTML regex
const htmlPattern = /<([a-z]+)([^>]*)>(.*?)<\/\1>/;

// Attack input (when used with global flag)
const html = "<a href='aaaaaaaaaaaaaaaaaaaaaa";
```

Incomplete tags can cause excessive backtracking.

## Defense Mechanisms

### 1. Never Use User Input as Regex

**Vulnerable:**

```javascript
const pattern = new RegExp(userInput);
```

**Secure:**

```javascript
// Use predefined patterns only
const allowedPatterns = {
  alphanumeric: /^[a-zA-Z0-9]+$/,
  email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
};

const pattern = allowedPatterns[userSelection];
```

### 2. Implement Regex Timeouts

**Node.js example:**

```javascript
function safeRegexTest(pattern, input, timeoutMs = 100) {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error("Regex timeout"));
    }, timeoutMs);

    try {
      const result = pattern.test(input);
      clearTimeout(timeout);
      resolve(result);
    } catch (e) {
      clearTimeout(timeout);
      reject(e);
    }
  });
}

// Usage
try {
  const result = await safeRegexTest(/pattern/, userInput, 100);
} catch (e) {
  console.error("Regex took too long or failed");
}
```

**Python example:**

```python
import re
import signal

def timeout_handler(signum, frame):
    raise TimeoutError("Regex timeout")

def safe_regex_match(pattern, text, timeout=1):
    signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(timeout)
    try:
        result = re.match(pattern, text)
        signal.alarm(0)
        return result
    except TimeoutError:
        return None
```

### 3. Use Safe Regex Patterns

**Avoid nested quantifiers:**

```javascript
// VULNERABLE
/^(a+)+$/
/^(a*)*$/
/^(a+)*$/

// SAFE
/^a+$/
/^a*$/
```

**Avoid alternation with overlap:**

```javascript
// VULNERABLE
/^(a|a)*$/
/^(a|ab)*$/

// SAFE
/^a*$/
/^(a|b)*$/
```

**Use possessive quantifiers (if supported):**

```javascript
// Possessive quantifiers don't backtrack
/^(a++)++$/  // Not supported in JavaScript

// JavaScript alternative: atomic groups via lookahead
/^(?=(a+))\1+$/
```

### 4. Validate Regex Complexity

Use tools to analyze regex patterns before deployment:

**safe-regex (npm package):**

```javascript
const safe = require("safe-regex");

const pattern = /^(a+)+$/;
if (!safe(pattern)) {
  console.error("Unsafe regex pattern detected!");
}
```

**redos-detector (npm package):**

```javascript
const redos = require("redos-detector");

const pattern = /^(a+)+$/;
const result = redos.isSafe(pattern);
if (!result.safe) {
  console.error("ReDoS vulnerability:", result.error);
}
```

### 5. Rate Limiting

Limit the number of validation attempts per user:

```javascript
const rateLimit = require("express-rate-limit");

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: "Too many requests, please try again later",
});

app.use("/api/", limiter);
```

### 6. Input Length Limits

Restrict input length to reduce backtracking time:

```javascript
function validateInput(input) {
  if (input.length > 100) {
    throw new Error("Input too long");
  }
  return pattern.test(input);
}
```

### 7. Use Alternative Validation Methods

Instead of regex, use:

**String methods:**

```javascript
// Instead of /^[a-zA-Z0-9]+$/
function isAlphanumeric(str) {
  for (let char of str) {
    const code = char.charCodeAt(0);
    if (
      !(code >= 48 && code <= 57) && // 0-9
      !(code >= 65 && code <= 90) && // A-Z
      !(code >= 97 && code <= 122)
    ) {
      // a-z
      return false;
    }
  }
  return true;
}
```

**Dedicated parsers:**

```javascript
// Instead of regex for URLs
const url = new URL(userInput); // Throws if invalid

// Instead of regex for emails
const emailValidator = require("email-validator");
emailValidator.validate(userInput);
```

## Detecting ReDoS in Production

### Monitoring Metrics

1. **Response time** - Alert on requests taking >1 second
2. **CPU usage** - Spike in CPU without corresponding traffic increase
3. **Event loop lag** - In Node.js, monitor `process.hrtime()`
4. **Request queue depth** - Growing queue indicates blocking

### Logging

```javascript
app.use((req, res, next) => {
  const start = Date.now();

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (duration > 1000) {
      console.warn(`Slow request: ${req.path} took ${duration}ms`);
    }
  });

  next();
});
```

### Alerting

Set up alerts for:

- Response time > 5 seconds
- CPU usage > 80% for > 30 seconds
- Event loop lag > 100ms

## Key Lessons

1. **Never use user input as regex patterns** - Validate against a whitelist of safe patterns

2. **Nested quantifiers are dangerous** - Patterns like `(a+)+` cause exponential backtracking

3. **Timeouts are essential** - Limit regex execution time to prevent blocking

4. **Test regex patterns** - Use tools like `safe-regex` to detect vulnerabilities

5. **Input length matters** - Even safe patterns can be slow with very long input

6. **Monitoring is crucial** - Detect ReDoS attacks in production through metrics

7. **Defense in depth** - Combine multiple strategies: safe patterns, timeouts, rate limiting, input validation

## Conclusion

ReDoS demonstrates that denial of service attacks don't always require network flooding. A single carefully crafted input can bring down an application by exploiting algorithmic complexity. The defense is straightforward—avoid nested quantifiers, implement timeouts, and never use user input as regex patterns—but requires awareness of the vulnerability. As applications increasingly rely on regex for validation, understanding and preventing ReDoS becomes essential for building resilient systems.
